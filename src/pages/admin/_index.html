
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="noindex" />
    <link href="/admin/config.yml" type="text/yaml" rel="cms-config-url" />
    <script type="text/javascript" src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>
    <title>The Kitchen Pot Content Manager</title>
  </head>
  <body>


    <script src="https://unpkg.com/decap-cms@^3.1.2/dist/decap-cms.js"></script>


<script>
  if (window.netlifyIdentity) {
    window.netlifyIdentity.init({
      APIUrl: 'https://thekitchenpot.com/.netlify/identity'
    });
  }
</script>
<script>
CMS.registerEditorComponent({
  // Internal id of the component
  id: "button-link",
  // Visible label
  label: "CTA Button",
  // Fields the user need to fill out when adding an instance of the component
  fields: [
    {
      name: 'text',
      label: 'CTA Text',
      widget: 'string'
    },
    {
      name: 'url',
      label: 'Link',
      widget: 'string'
    }
  ],
  // Regex pattern used to search for instances of this block in the markdown document.
  // Patterns are run in a multiline environment (against the entire markdown document),
  // and so generally should make use of the multiline flag (`m`). If you need to capture
  // newlines in your capturing groups, you can either use something like
  // `([\S\s]*)`, or you can additionally enable the "dot all" flag (`s`),
  // which will cause `(.*)` to match newlines as well.
  //
  // Additionally, it's recommended that you use non-greedy capturing groups (e.g.
  // `(.*?)` vs `(.*)`), especially if matching against newline characters.
  //pattern: /^<details><summary>(.*?)<\/summary>(.*?)<\/details>$/ms,
  // Given a RegExp Match object
  // (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match#return_value),
  // return an object with one property for each field defined in `fields`.
  //
  // This is used to populate the custom widget in the markdown editor in the CMS.
  fromBlock: function(match) {
    return {
      text: match[1],
      url: match[2]
    };
  },
  // Given an object with one property for each field defined in `fields`,
  // return the string you wish to be inserted into your markdown.
  //
  // This is used to serialize the data from the custom widget to the
  // markdown document
  // return `<a href="${data.url}">${data.text}</a>`;
  toBlock: function(data) {
    return `<a href="${data.url}">${data.text}</a>`; //`<details><summary>${data.text}</summary>${data.url}</details>`;
  },
  // Preview output for this component. Can either be a string or a React component
  // (component gives better render performance)
  toPreview: function(data) {
    return `<a href="${data.url}">${data.text}</a>`;
  }
});
</script>
  </body>
</html>